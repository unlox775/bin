#!/usr/bin/env python3

import inquirer
import boto3
import sys
import os
import signal
import subprocess
import botocore.exceptions
import argparse

# Import the AWS helpers library
from lib.ec2_proxy import EC2Proxy
from lib.aws_common import AWSCommon

# Initialize AWS helpers
ec2_proxy = EC2Proxy()
aws_common = AWSCommon()

def check_aws_access():
    """Check if we have valid AWS credentials and permissions for SSM sessions"""
    return ec2_proxy.check_aws_ssm_access()

def get_rds_instances(search_term):
    """Find RDS MySQL instances matching the search term"""
    # Use AWSCommon for centralized region handling
    rds = aws_common.get_boto3_client('rds')
    
    # List all RDS instances
    response = rds.describe_db_instances()
    
    # Convert search term to lowercase for case-insensitive comparison
    search_term_lower = search_term.lower()
    
    result = []
    for instance in response['DBInstances']:
        # Only include MySQL instances
        if 'mysql' not in instance['Engine'].lower():
            continue
            
        instance_id = instance['DBInstanceIdentifier']
        endpoint = instance['Endpoint']['Address']
        port = instance['Endpoint']['Port']
        engine = instance['Engine']
        resource_id = instance.get('DbiResourceId', '')
        db_name = instance.get('DBName', '')
        master_username = instance.get('MasterUsername', '')
        
        # Get tags if they exist
        tags = {}
        try:
            tag_list = rds.list_tags_for_resource(ResourceName=instance['DBInstanceArn'])
            tags = {tag['Key']: tag['Value'] for tag in tag_list.get('TagList', [])}
        except Exception:
            # Some instances might not support tagging or we might not have permission
            pass
        
        # Check all relevant fields for the search term
        if any([
            search_term_lower in instance_id.lower(),                # Instance ID
            search_term_lower in endpoint.lower(),                   # Endpoint address
            search_term_lower in engine.lower(),                     # Engine type (e.g., aurora-mysql)
            db_name and search_term_lower in db_name.lower(),        # Database name if available
            search_term_lower in resource_id.lower(),                # Resource ID
            search_term_lower in master_username.lower(),            # Master username
            # Check all tag values
            any(search_term_lower in value.lower() for value in tags.values()),
            # Check all tag keys
            any(search_term_lower in key.lower() for key in tags.keys())
        ]):
            # Create a dictionary of relevant instance information
            instance_info = {
                'id': instance_id,
                'endpoint': endpoint,
                'port': port,
                'engine': engine,
                'resource_id': resource_id,
                'db_name': db_name if db_name else 'N/A',
                'master_username': master_username,
                'tags': tags
            }
            result.append(instance_info)
    
    return result

def select_rds_instance(rds_instances):
    """Present a menu to select an RDS instance"""
    if not rds_instances:
        print("No RDS MySQL instances found matching the search term.")
        sys.exit(1)
        
    choices = [f"{instance['id']} - {instance['endpoint']} ({instance['engine']})" for instance in rds_instances]
    
    questions = [
        inquirer.List('selected_instance',
                      message="Which RDS instance do you want to connect to?",
                      choices=choices)
    ]
    
    try:
        answers = inquirer.prompt(questions)
        if answers is None:
            print("\nSelection cancelled. Exiting.")
            sys.exit(0)
        selected_index = choices.index(answers['selected_instance'])
        return rds_instances[selected_index]
    except KeyboardInterrupt:
        print("\nOperation cancelled. Exiting.")
        sys.exit(0)

def setup_port_forwarding(rds_endpoint, rds_port, local_port=None):
    """Setup port forwarding using an EC2 instance with SSM"""
    # Print MySQL-specific connection info
    print(f"\nConnect using:")
    print(f"  mysql -h 127.0.0.1 -P {local_port} -u <username> -p<password> <database>")
    
    # Use the EC2 proxy's port forwarding with MySQL-specific connection info
    ec2_proxy.setup_port_forwarding(
        target_host=rds_endpoint,
        target_port=rds_port,
        local_port=local_port,
        service_name="RDS MySQL"
    )

def main():
    parser = argparse.ArgumentParser(
        description='''RDS MySQL port forwarding tool using AWS Systems Manager.

This tool establishes secure port forwarding to RDS MySQL instances through AWS Systems 
Manager (SSM), allowing local database connections without requiring VPN or bastion hosts. 
It searches for MySQL RDS instances and provides an interactive selection menu.

Key use cases:
- Database access: Connect to RDS MySQL instances from local development environments
- Secure tunneling: Access private RDS instances without VPN or public endpoints
- Development: Local database connections for application development
- Troubleshooting: Direct database access for debugging and maintenance
- Multi-account access: Connect to RDS instances across different AWS accounts

The tool validates AWS credentials and SSM permissions, searches for MySQL RDS instances 
by name or tags, and establishes port forwarding through an available EC2 instance with 
SSM agent. It provides connection strings for local database clients.

Environment Variables:
- AWS_SSM_DEFAULT_EC2_INSTANCE: Set to an EC2 instance ID to skip instance selection
  Example: export AWS_SSM_DEFAULT_EC2_INSTANCE=i-1234567890abcdef0
- AWS_SSM_DEFAULT_EC2_NAME: Set to an instance name or stack name to skip instance selection
  Example: export AWS_SSM_DEFAULT_EC2_NAME=my-instance-name
  Example: export AWS_SSM_DEFAULT_EC2_NAME=my-stack-name''',
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    parser.add_argument('search_term', help='Search term to match RDS instance names, tags, or endpoints')
    parser.add_argument('local_port', help='Local port for forwarding (default: 13306)', nargs='?', type=int, default=13306)
    args = parser.parse_args()

    # Get search term from first CLI arg
    search_term = args.search_term
    
    # Get optional local port from second CLI arg
    local_port = args.local_port
    if local_port < 1024 or local_port > 65535:
        print("ERROR: Local port must be between 1024 and 65535")
        sys.exit(1)
    
    # Check AWS access before proceeding - this now checks SSM permissions too
    check_aws_access()
    
    # Find RDS instances matching the search term
    print(f"Searching for MySQL RDS instances matching: {search_term}")
    rds_instances = get_rds_instances(search_term)
    
    if not rds_instances:
        print("No MySQL RDS instances found matching the search term.")
        sys.exit(1)
    
    # Let user select an RDS instance
    selected_rds = select_rds_instance(rds_instances)
    
    # Setup port forwarding to RDS through an EC2 instance
    setup_port_forwarding(
        selected_rds['endpoint'], 
        selected_rds['port'],
        local_port
    )

if __name__ == "__main__":
    main()